# Description: Compute sub-grid correction factors for direct shortwave#              downward radiation (aggregated to the regional climate model#              grid resolution)## Copyright (c) 2023 ETH Zurich, Christian R. Steger# MIT License# Load modulesimport osimport numpy as npimport xarray as xrimport cartopy.crs as ccrsimport cartopy.feature as cfeatureimport matplotlib.pyplot as pltimport matplotlib as mplfrom skyfield.api import Distancefrom cmcrameri import cmfrom netCDF4 import Datasetimport shortwave_subgrid as swsgfrom utilities.grid import grid_framefrom utilities.plot import truncate_colormapmpl.style.use("classic")# %matplotlib auto# %matplotlib auto# -----------------------------------------------------------------------------# Settings# -----------------------------------------------------------------------------# Grid for subsolar points# subsol_lon = np.linspace(-180.0, 174.0,60, dtype=np.float64)  # 6 degree# subsol_lat = np.linspace(-23.5, 23.5, 21, dtype=np.float64)  # 2.35 degreesubsol_lon = np.linspace(-180.0, 172.0, 45, dtype=np.float64)  # 8 degreesubsol_lat = np.linspace(-23.5, 23.5, 15, dtype=np.float64)  # 3.36 degree# Ray-tracing and 'SW_dir_cor' calcuationdist_search = 50.0  # search distance for terrain shading [kilometre]  ####### temporary!geom_type = "quad"  # "quad" ca. 25% faster than "grid"ang_max = 89.5sw_dir_cor_max = 20.0# Miscellaneous settingsdir_work = "/Users/csteger/Desktop/dir_work/"  # working directoryellps = "sphere"  # Earth's surface approximation (sphere, GRS80 or WGS84)plot = False# -----------------------------------------------------------------------------# Load and check data# -----------------------------------------------------------------------------# Load datads = xr.open_dataset(dir_work + "MERIT_remapped_COSMO.nc")num_gc = ds.attrs["sub_grid_info_zonal"]offset = ds.attrs["offset_grid_cells_zonal"]# -----------------------------------------------------------------------------# -> use sub-domain with reduces boundary with for now...offset = int(offset / 2)ds = ds.isel(rlat=slice(325 * num_gc - num_gc * offset,                        355 * num_gc + 1 + num_gc * offset),             rlon=slice(265 * num_gc - num_gc * offset,                        315 * num_gc + 1 + num_gc * offset))  # 30 x 50# -----------------------------------------------------------------------------lon = ds["lon"].values.astype(np.float64)lat = ds["lat"].values.astype(np.float64)elevation = ds["Elevation"].valuespole_lon = ds["rotated_pole"].grid_north_pole_longitudepole_lat = ds["rotated_pole"].grid_north_pole_latituderlon = ds["rlon"].valuesrlat = ds["rlat"].valuesds.close()# Test plotif plot:    cmap = truncate_colormap(plt.get_cmap("terrain"), val_min=0.3, val_max=1.0)    levels = np.arange(0.0, 5000.0, 250.0)    norm = mpl.colors.BoundaryNorm(levels, ncolors=cmap.N, extend="max")    # -------------------------------------------------------------------------    ccrs_rot_pole = ccrs.RotatedPole(pole_latitude=pole_lat,                                     pole_longitude=pole_lon)    plt.figure(figsize=(12, 8))    ax = plt.axes(projection=ccrs_rot_pole)    plt.pcolormesh(rlon, rlat, elevation, cmap=cmap, norm=norm)    # -------------------------------------------------------------------------    plt.vlines(x=rlon[0:None:num_gc], ymin=rlat[0], ymax=rlat[-1],               color="grey", lw=0.5, zorder=2)    plt.hlines(y=rlat[0:None:num_gc], xmin=rlon[0], xmax=rlon[-1],               color="grey", lw=0.5, zorder=2)    # -------------------------------------------------------------------------    rlon_fr, rlat_fr = grid_frame(rlon, rlat, offset=0)    poly = plt.Polygon(list(zip(rlon_fr, rlat_fr)), facecolor="none",                       edgecolor="black", alpha=1.0, linewidth=1.5, zorder=3)    ax.add_patch(poly)    rlon_fr, rlat_fr = grid_frame(rlon, rlat, offset=num_gc * offset)    poly = plt.Polygon(list(zip(rlon_fr, rlat_fr)), facecolor="none",                       edgecolor="black", alpha=1.0, linewidth=1.5, zorder=3)    ax.add_patch(poly)    # -------------------------------------------------------------------------    ax.set_aspect("auto")    ax.add_feature(cfeature.BORDERS.with_scale("10m"), linestyle="-", zorder=3)    plt.colorbar()# -----------------------------------------------------------------------------# Coordinate transformation# -----------------------------------------------------------------------------# Transform elevation data (geographic/geodetic -> ENU coordinates)x_ecef, y_ecef, z_ecef = swsg.transform.lonlat2ecef(lon, lat, elevation,                                                    ellps=ellps)dem_dim_0, dem_dim_1 = elevation.shapetrans_ecef2enu = swsg.transform.TransformerEcef2enu(    lon_or=lon.mean(), lat_or=lat.mean(), ellps=ellps)x_enu, y_enu, z_enu = swsg.transform.ecef2enu(x_ecef, y_ecef, z_ecef,                                              trans_ecef2enu)del x_ecef, y_ecef, z_ecef# Test plotif plot:    plt.figure()    plt.pcolormesh(x_enu, y_enu, z_enu)    plt.colorbar()# Merge vertex coordinates and pad geometry buffervert_grid = swsg.auxiliary.rearrange_pad_buffer(x_enu, y_enu, z_enu)print("Size of elevation data: %.3f" % (vert_grid.nbytes / (10 ** 9))      + " GB")del x_enu, y_enu, z_enu# Transform 0.0 m surface data (geographic/geodetic -> ENU coordinates)slice_in = (slice(num_gc * offset, -num_gc * offset),            slice(num_gc * offset, -num_gc * offset))elevation_zero = np.zeros_like(elevation)x_ecef, y_ecef, z_ecef \    = swsg.transform.lonlat2ecef(lon[slice_in], lat[slice_in],                                 elevation_zero[slice_in], ellps=ellps)dem_dim_in_0, dem_dim_in_1 = elevation_zero[slice_in].shapex_enu, y_enu, z_enu = swsg.transform.ecef2enu(x_ecef, y_ecef, z_ecef,                                              trans_ecef2enu)del x_ecef, y_ecef, z_ecef# Test plotif plot:    plt.figure()    plt.pcolormesh(x_enu, y_enu, z_enu)    plt.colorbar()# Merge vertex coordinates and pad geometry buffervert_grid_in = swsg.auxiliary.rearrange_pad_buffer(x_enu, y_enu, z_enu)print("Size of elevation data (0.0 m surface): %.3f"      % (vert_grid_in.nbytes / (10 ** 9)) + " GB")del x_enu, y_enu, z_enu# Transform locations of subsolar pointssubsol_lon, subsol_lat = np.meshgrid(subsol_lon, subsol_lat)subsol_dist = np.empty(subsol_lon.shape, dtype=np.float32)subsol_dist[:] = Distance(au=1).m# astronomical unit (~average Sun-Earth distance) [m]x_ecef, y_ecef, z_ecef \    = swsg.transform.lonlat2ecef(subsol_lon, subsol_lat,                                 subsol_dist, ellps=ellps)x_enu, y_enu, z_enu = swsg.transform.ecef2enu(x_ecef, y_ecef, z_ecef,                                              trans_ecef2enu)# Test plotif plot:    fig = plt.figure()    ax = fig.add_subplot(projection="3d")    ax.scatter(0.0, 0.0, 0.0 , marker=".", s=100, color="lightblue")    # ax.scatter(x_ecef.ravel(), y_ecef.ravel(), z_ecef.ravel() , marker=".",    #            s=20, color="orangered")    # ax.set_xlabel("x-axis")    # ax.set_ylabel("y-axis")    # ax.set_zlabel("z-axis")    ax.scatter(x_enu.ravel(), y_enu.ravel(), z_enu.ravel() , marker=".",               s=20, color="orangered")    ax.set_xlabel("East")    ax.set_ylabel("North")    ax.set_zlabel("Up")# Combine sun position in one arraysun_pos = np.concatenate((x_enu[:, :, np.newaxis],                          y_enu[:, :, np.newaxis],                          z_enu[:, :, np.newaxis]), axis=2)# -----------------------------------------------------------------------------# Compute spatially aggregated correction factors# -----------------------------------------------------------------------------# Computepixel_per_gc = num_gc  # pixel per grid cell (along one dimension; 24)offset_gc = offset     # offset in number of grid cells (22)sw_dir_cor = swsg.subsolar_lookup.sw_dir_cor(    vert_grid, dem_dim_0, dem_dim_1,    vert_grid_in, dem_dim_in_0, dem_dim_in_1,    sun_pos, pixel_per_gc, offset_gc,    dist_search=dist_search, geom_type=geom_type,    ang_max=ang_max, sw_dir_cor_max=sw_dir_cor_max)# Check outputprint("Range of 'sw_dir_cor'-values: [%.2f" % sw_dir_cor.min()      + ", %.2f" % sw_dir_cor.max() + "]")# Test plotif plot:    levels = np.arange(0.0, 2.0, 0.2)    cmap = cm.roma_r    norm = mpl.colors.BoundaryNorm(levels, ncolors=cmap.N, clip=False,                                   extend="max")    plt.figure()    plt.pcolormesh(sw_dir_cor[13, 25, :, :], cmap=cmap, norm=norm)    # plt.pcolormesh(sw_dir_cor[:, :, 0, 22], cmap=cmap, norm=norm)    plt.colorbar()# Select relevant subsolar longitude range (add -/+ 1)mask = (sw_dir_cor.sum(axis=(0, 1, 2)) != 0)slic = slice(np.maximum(np.where(mask)[0][0] - 1, 0),             np.minimum(np.where(mask)[0][-1] + 2, len(mask)))print(mask[slic])print("Size of lookup table: %.2f"      % (sw_dir_cor[:, :, :, slic].nbytes / (10 ** 6)) + " MB")# Save to NetCDF filencfile = Dataset(filename=dir_work + "SW_dir_cor_lookup.nc", mode="w")ncfile.ang_max = "%.2f" % ang_max + " degrees"ncfile.sw_dir_cor_max = "%.2f" % sw_dir_cor_max# -----------------------------------------------------------------------------ncfile.createDimension(dimname="gc_lat", size=sw_dir_cor.shape[0])ncfile.createDimension(dimname="gc_lon", size=sw_dir_cor.shape[1])ncfile.createDimension(dimname="subsolar_lat", size=sw_dir_cor.shape[2])ncfile.createDimension(dimname="subsolar_lon", size=mask[slic].size)# -----------------------------------------------------------------------------nc_sslat = ncfile.createVariable(varname="subsolar_lat", datatype="f",                                dimensions="subsolar_lat")nc_sslat[:] = subsol_lat[:, 0]nc_sslat.long_name = "subsolar latitude"nc_sslat.units = "degrees"nc_sslon = ncfile.createVariable(varname="subsolar_lon", datatype="f",                                dimensions="subsolar_lon")nc_sslon[:] = subsol_lon[0, :][slic]nc_sslon.long_name = "subsolar longitude"nc_sslon.units = "degrees"# -----------------------------------------------------------------------------nc_data = ncfile.createVariable(varname="f_cor", datatype="f",                                dimensions=("gc_lat", "gc_lon",                                            "subsolar_lat", "subsolar_lon"))nc_data[:] = sw_dir_cor[:, :, :, slic]nc_data.units = "-"# -----------------------------------------------------------------------------ncfile.close()# Test loadds = xr.open_dataset(dir_work + "SW_dir_cor_lookup.nc")f_cor = ds["f_cor"].valuesds.close()